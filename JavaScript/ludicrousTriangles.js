// Introduction
// This kata is yet another version of Avanta's Coloured Triangles, once again focused on performance.

// It takes Bubbler's "Insane" version a step further, hence the name "Ludicrous".

// I highly recommend having a close look at these other versions first, and solving them if you haven't already: they are super nice kata, and the test cases are significantly less challenging than what you'll find here.

// Problem Description
// This section has been borrowed from Avanta's kata.

// A coloured triangle is created from a row of colours, each of which is red, green or blue.Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row.If these colours are identical, the same colour is used in the new row.If they are different, the missing colour is used in the new row.This is continued until the final row, with only a single colour, is generated.

// For example, different possibilities are:

// Colour here: G G        B G        R G        B R
// Becomes colour here: G          R          B          G
// With a bigger example:

// R R G B R G B B
// R B R G B R B
// G G B R G G
// G R G B G
// B B R R
// B G R
// R B
// G
// You will be given the first row of the triangle as a string and its your job to return the final colour which would appear in the bottom row as a string.In the case of the example above, you would the given 'RRGBRGBB' you should return 'G'.

// The input string will only contain the uppercase letters 'B', 'G' or 'R' and there will be at least one letter so you do not have to test for invalid input.
// If you are only given one colour as the input, return that colour.
// Adapted from the 2017 British Informatics Olympiad

// Challenge
// The specificity of this kata resides in the very large size of the input strings that your function will have to crunch and digest.

// As a reference, the test cases in Bubbler's Insane version go up to 100 000 characters. In this one, the limit is set to 1 000 000 000 characters. (That's 10 000 times more.)

// With such large numbers, the challenge here will clearly not be about optimizing code execution, but about reducing algorithmic complexity.

// Please note that the test cases are randomly generated, so the actual time it takes to complete the tests can vary from one attempt to the next.A good solution, though, should be able to beat the timeout 99 % of the time.

const colour = {
  RR: "R",
  BB: "B",
  GG: "G",
  RB: "G",
  BR: "G",
  BG: "R",
  GB: "R",
  RG: "B",
  GR: "B",
};

function triangle(row) {
  function break_triangle(g, i, b) {
    if (g == 1) return row[i];
    let x = 3 ** b;
    while (g <= x) x = 3 ** --b;
    return colour[
      break_triangle(g - x, i, b) + break_triangle(g - x, i + x, b)
    ];
  }
  return break_triangle(
    row.length,
    0,
    ~~(Math.log(row.length - 1) / Math.log(3))
  );
}
